<?php
/**
 * TransactionalMessagingApi
 * PHP version 5
 *
 * @category Class
 * @package  SalesForce\MarketingCloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Marketing Cloud REST API
 *
 * Marketing Cloud's REST API is our newest API. It supports multi-channel use cases, is much more lightweight and easy to use than our SOAP API, and is getting more comprehensive with every release.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: mc_sdk@salesforce.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace SalesForce\MarketingCloud\Api;

use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use SalesForce\MarketingCloud\Api\Exception\ExceptionFactory;
use SalesForce\MarketingCloud\Api\Exception\InvalidRequestException;
use SalesForce\MarketingCloud\ApiException;
use SalesForce\MarketingCloud\ObjectSerializer;


/**
 * TransactionalMessagingApi Class Doc Comment
 *
 * @category Class
 * @package  SalesForce\MarketingCloud
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TransactionalMessagingApi extends AbstractApi
{

    /**
     * Operation createEmailDefinition
     *
     * createEmailDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest
     */
    public function createEmailDefinition(\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body)
    {
        list($response) = $this->createEmailDefinitionWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createEmailDefinitionWithHttpInfo
     *
     * createEmailDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function createEmailDefinitionWithHttpInfo(\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest';
        $request = $this->createEmailDefinitionRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createEmailDefinitionAsync
     *
     * createEmailDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function createEmailDefinitionAsync(\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body)
    {
        return $this->createEmailDefinitionAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEmailDefinitionAsyncWithHttpInfo
     *
     * createEmailDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function createEmailDefinitionAsyncWithHttpInfo(\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest';
        $request = $this->createEmailDefinitionRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEmailDefinition'
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createEmailDefinitionRequest(\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createEmailDefinition'
            );
        }

        $resourcePath = '/messaging/v1/email/definitions/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSmsDefinition
     *
     * createSmsDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest
     */
    public function createSmsDefinition(\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body)
    {
        list($response) = $this->createSmsDefinitionWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createSmsDefinitionWithHttpInfo
     *
     * createSmsDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function createSmsDefinitionWithHttpInfo(\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest';
        $request = $this->createSmsDefinitionRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSmsDefinitionAsync
     *
     * createSmsDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function createSmsDefinitionAsync(\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body)
    {
        return $this->createSmsDefinitionAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSmsDefinitionAsyncWithHttpInfo
     *
     * createSmsDefinition
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function createSmsDefinitionAsyncWithHttpInfo(\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest';
        $request = $this->createSmsDefinitionRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSmsDefinition'
     *
     * @param  \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createSmsDefinitionRequest(\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createSmsDefinition'
            );
        }

        $resourcePath = '/messaging/v1/sms/definitions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEmailDefinition
     *
     * deleteEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse
     */
    public function deleteEmailDefinition(string $definitionKey)
    {
        list($response) = $this->deleteEmailDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation deleteEmailDefinitionWithHttpInfo
     *
     * deleteEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function deleteEmailDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse';
        $request = $this->deleteEmailDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteEmailDefinitionAsync
     *
     * deleteEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function deleteEmailDefinitionAsync(string $definitionKey)
    {
        return $this->deleteEmailDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEmailDefinitionAsyncWithHttpInfo
     *
     * deleteEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function deleteEmailDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse';
        $request = $this->deleteEmailDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEmailDefinition'
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteEmailDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling deleteEmailDefinition'
            );
        }

        $resourcePath = '/messaging/v1/email/definitions/{definitionKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteQueuedMessagesForEmailDefinition
     *
     * deleteQueuedMessagesForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse
     */
    public function deleteQueuedMessagesForEmailDefinition(string $definitionKey)
    {
        list($response) = $this->deleteQueuedMessagesForEmailDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation deleteQueuedMessagesForEmailDefinitionWithHttpInfo
     *
     * deleteQueuedMessagesForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function deleteQueuedMessagesForEmailDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse';
        $request = $this->deleteQueuedMessagesForEmailDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteQueuedMessagesForEmailDefinitionAsync
     *
     * deleteQueuedMessagesForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function deleteQueuedMessagesForEmailDefinitionAsync(string $definitionKey)
    {
        return $this->deleteQueuedMessagesForEmailDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteQueuedMessagesForEmailDefinitionAsyncWithHttpInfo
     *
     * deleteQueuedMessagesForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function deleteQueuedMessagesForEmailDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse';
        $request = $this->deleteQueuedMessagesForEmailDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteQueuedMessagesForEmailDefinition'
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteQueuedMessagesForEmailDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling deleteQueuedMessagesForEmailDefinition'
            );
        }

        $resourcePath = '/messaging/v1/email/definitions/{definitionKey}/queue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteQueuedMessagesForSmsDefinition
     *
     * deleteQueuedMessagesForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse
     */
    public function deleteQueuedMessagesForSmsDefinition(string $definitionKey)
    {
        list($response) = $this->deleteQueuedMessagesForSmsDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation deleteQueuedMessagesForSmsDefinitionWithHttpInfo
     *
     * deleteQueuedMessagesForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function deleteQueuedMessagesForSmsDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse';
        $request = $this->deleteQueuedMessagesForSmsDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteQueuedMessagesForSmsDefinitionAsync
     *
     * deleteQueuedMessagesForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function deleteQueuedMessagesForSmsDefinitionAsync(string $definitionKey)
    {
        return $this->deleteQueuedMessagesForSmsDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteQueuedMessagesForSmsDefinitionAsyncWithHttpInfo
     *
     * deleteQueuedMessagesForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function deleteQueuedMessagesForSmsDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteQueuedMessagesForSendDefinitionResponse';
        $request = $this->deleteQueuedMessagesForSmsDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteQueuedMessagesForSmsDefinition'
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteQueuedMessagesForSmsDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling deleteQueuedMessagesForSmsDefinition'
            );
        }

        $resourcePath = '/messaging/v1/sms/definitions/{definitionKey}/queue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSmsDefinition
     *
     * deleteSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse
     */
    public function deleteSmsDefinition(string $definitionKey)
    {
        list($response) = $this->deleteSmsDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation deleteSmsDefinitionWithHttpInfo
     *
     * deleteSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function deleteSmsDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse';
        $request = $this->deleteSmsDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSmsDefinitionAsync
     *
     * deleteSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function deleteSmsDefinitionAsync(string $definitionKey)
    {
        return $this->deleteSmsDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSmsDefinitionAsyncWithHttpInfo
     *
     * deleteSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function deleteSmsDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\DeleteSendDefinitionResponse';
        $request = $this->deleteSmsDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSmsDefinition'
     *
     * @param  string $definitionKey Unique identifier of the definition to delete (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSmsDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling deleteSmsDefinition'
            );
        }

        $resourcePath = '/messaging/v1/sms/definitions/{definitionKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailDefinition
     *
     * getEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest
     */
    public function getEmailDefinition(string $definitionKey)
    {
        list($response) = $this->getEmailDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation getEmailDefinitionWithHttpInfo
     *
     * getEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getEmailDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest';
        $request = $this->getEmailDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailDefinitionAsync
     *
     * getEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getEmailDefinitionAsync(string $definitionKey)
    {
        return $this->getEmailDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailDefinitionAsyncWithHttpInfo
     *
     * getEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getEmailDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest';
        $request = $this->getEmailDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailDefinition'
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling getEmailDefinition'
            );
        }

        $resourcePath = '/messaging/v1/email/definitions/{definitionKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailDefinitions
     *
     * getEmailDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetEmailDefinitionsResponse
     */
    public function getEmailDefinitions(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        list($response) = $this->getEmailDefinitionsWithHttpInfo($filter, $pageSize, $page, $orderBy);
        return $response;
    }

    /**
     * Operation getEmailDefinitionsWithHttpInfo
     *
     * getEmailDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetEmailDefinitionsResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getEmailDefinitionsWithHttpInfo(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetEmailDefinitionsResponse';
        $request = $this->getEmailDefinitionsRequest($filter, $pageSize, $page, $orderBy);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetEmailDefinitionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailDefinitionsAsync
     *
     * getEmailDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getEmailDefinitionsAsync(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        return $this->getEmailDefinitionsAsyncWithHttpInfo($filter, $pageSize, $page, $orderBy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailDefinitionsAsyncWithHttpInfo
     *
     * getEmailDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getEmailDefinitionsAsyncWithHttpInfo(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetEmailDefinitionsResponse';
        $request = $this->getEmailDefinitionsRequest($filter, $pageSize, $page, $orderBy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailDefinitions'
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailDefinitionsRequest(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();


        $resourcePath = '/messaging/v1/email/definitions/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter !== null) {
            $queryParams['$filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($pageSize !== null) {
            $queryParams['$pageSize'] = ObjectSerializer::toQueryValue($pageSize);
        }
        // query params
        if ($page !== null) {
            $queryParams['$page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($orderBy !== null) {
            $queryParams['$orderBy'] = ObjectSerializer::toQueryValue($orderBy);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailSendStatusForRecipient
     *
     * getEmailSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide it in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse
     */
    public function getEmailSendStatusForRecipient(string $messageKey)
    {
        list($response) = $this->getEmailSendStatusForRecipientWithHttpInfo($messageKey);
        return $response;
    }

    /**
     * Operation getEmailSendStatusForRecipientWithHttpInfo
     *
     * getEmailSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide it in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getEmailSendStatusForRecipientWithHttpInfo(string $messageKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse';
        $request = $this->getEmailSendStatusForRecipientRequest($messageKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailSendStatusForRecipientAsync
     *
     * getEmailSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide it in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getEmailSendStatusForRecipientAsync(string $messageKey)
    {
        return $this->getEmailSendStatusForRecipientAsyncWithHttpInfo($messageKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailSendStatusForRecipientAsyncWithHttpInfo
     *
     * getEmailSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide it in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getEmailSendStatusForRecipientAsyncWithHttpInfo(string $messageKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse';
        $request = $this->getEmailSendStatusForRecipientRequest($messageKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailSendStatusForRecipient'
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide it in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailSendStatusForRecipientRequest(string $messageKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'messageKey' is set
        if ($messageKey === null || (is_array($messageKey) && count($messageKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $messageKey when calling getEmailSendStatusForRecipient'
            );
        }

        $resourcePath = '/messaging/v1/email/messages/{messageKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($messageKey !== null) {
            $resourcePath = str_replace(
                '{' . 'messageKey' . '}',
                ObjectSerializer::toPathValue($messageKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailsNotSentToRecipients
     *
     * getEmailsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse
     */
    public function getEmailsNotSentToRecipients(string $type, int $pageSize = null, int $lastEventId = null)
    {
        list($response) = $this->getEmailsNotSentToRecipientsWithHttpInfo($type, $pageSize, $lastEventId);
        return $response;
    }

    /**
     * Operation getEmailsNotSentToRecipientsWithHttpInfo
     *
     * getEmailsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getEmailsNotSentToRecipientsWithHttpInfo(string $type, int $pageSize = null, int $lastEventId = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse';
        $request = $this->getEmailsNotSentToRecipientsRequest($type, $pageSize, $lastEventId);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailsNotSentToRecipientsAsync
     *
     * getEmailsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getEmailsNotSentToRecipientsAsync(string $type, int $pageSize = null, int $lastEventId = null)
    {
        return $this->getEmailsNotSentToRecipientsAsyncWithHttpInfo($type, $pageSize, $lastEventId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailsNotSentToRecipientsAsyncWithHttpInfo
     *
     * getEmailsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getEmailsNotSentToRecipientsAsyncWithHttpInfo(string $type, int $pageSize = null, int $lastEventId = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse';
        $request = $this->getEmailsNotSentToRecipientsRequest($type, $pageSize, $lastEventId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailsNotSentToRecipients'
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailsNotSentToRecipientsRequest(string $type, int $pageSize = null, int $lastEventId = null)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getEmailsNotSentToRecipients'
            );
        }

        $resourcePath = '/messaging/v1/email/messages/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($pageSize !== null) {
            $queryParams['$pageSize'] = ObjectSerializer::toQueryValue($pageSize);
        }
        // query params
        if ($lastEventId !== null) {
            $queryParams['lastEventId'] = ObjectSerializer::toQueryValue($lastEventId);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getQueueMetricsForEmailDefinition
     *
     * getQueueMetricsForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse
     */
    public function getQueueMetricsForEmailDefinition(string $definitionKey)
    {
        list($response) = $this->getQueueMetricsForEmailDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation getQueueMetricsForEmailDefinitionWithHttpInfo
     *
     * getQueueMetricsForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getQueueMetricsForEmailDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse';
        $request = $this->getQueueMetricsForEmailDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getQueueMetricsForEmailDefinitionAsync
     *
     * getQueueMetricsForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getQueueMetricsForEmailDefinitionAsync(string $definitionKey)
    {
        return $this->getQueueMetricsForEmailDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getQueueMetricsForEmailDefinitionAsyncWithHttpInfo
     *
     * getQueueMetricsForEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getQueueMetricsForEmailDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse';
        $request = $this->getQueueMetricsForEmailDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getQueueMetricsForEmailDefinition'
     *
     * @param  string $definitionKey Unique identifier of the email definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getQueueMetricsForEmailDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling getQueueMetricsForEmailDefinition'
            );
        }

        $resourcePath = '/messaging/v1/email/definitions/{definitionKey}/queue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getQueueMetricsForSmsDefinition
     *
     * getQueueMetricsForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse
     */
    public function getQueueMetricsForSmsDefinition(string $definitionKey)
    {
        list($response) = $this->getQueueMetricsForSmsDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation getQueueMetricsForSmsDefinitionWithHttpInfo
     *
     * getQueueMetricsForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getQueueMetricsForSmsDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse';
        $request = $this->getQueueMetricsForSmsDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getQueueMetricsForSmsDefinitionAsync
     *
     * getQueueMetricsForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getQueueMetricsForSmsDefinitionAsync(string $definitionKey)
    {
        return $this->getQueueMetricsForSmsDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getQueueMetricsForSmsDefinitionAsyncWithHttpInfo
     *
     * getQueueMetricsForSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getQueueMetricsForSmsDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetQueueMetricsForSendDefinitionResponse';
        $request = $this->getQueueMetricsForSmsDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getQueueMetricsForSmsDefinition'
     *
     * @param  string $definitionKey Unique identifier of the SMS definition (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getQueueMetricsForSmsDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling getQueueMetricsForSmsDefinition'
            );
        }

        $resourcePath = '/messaging/v1/sms/definitions/{definitionKey}/queue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSMSsNotSentToRecipients
     *
     * getSMSsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse
     */
    public function getSMSsNotSentToRecipients(string $type, int $pageSize = null, int $lastEventId = null)
    {
        list($response) = $this->getSMSsNotSentToRecipientsWithHttpInfo($type, $pageSize, $lastEventId);
        return $response;
    }

    /**
     * Operation getSMSsNotSentToRecipientsWithHttpInfo
     *
     * getSMSsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getSMSsNotSentToRecipientsWithHttpInfo(string $type, int $pageSize = null, int $lastEventId = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse';
        $request = $this->getSMSsNotSentToRecipientsRequest($type, $pageSize, $lastEventId);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSMSsNotSentToRecipientsAsync
     *
     * getSMSsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getSMSsNotSentToRecipientsAsync(string $type, int $pageSize = null, int $lastEventId = null)
    {
        return $this->getSMSsNotSentToRecipientsAsyncWithHttpInfo($type, $pageSize, $lastEventId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSMSsNotSentToRecipientsAsyncWithHttpInfo
     *
     * getSMSsNotSentToRecipients
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getSMSsNotSentToRecipientsAsyncWithHttpInfo(string $type, int $pageSize = null, int $lastEventId = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionsNotSentToRecipientsResponse';
        $request = $this->getSMSsNotSentToRecipientsRequest($type, $pageSize, $lastEventId);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSMSsNotSentToRecipients'
     *
     * @param  string $type Only notSent is supported. (required)
     * @param  int $pageSize Number of messageKeys (array elements) to return per response page. (optional)
     * @param  int $lastEventId Event ID from which you want the response to start. To obtain the initial event ID, submit a request without a lastEventId. The events in the response are listed top to bottom from oldest to newest. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSMSsNotSentToRecipientsRequest(string $type, int $pageSize = null, int $lastEventId = null)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getSMSsNotSentToRecipients'
            );
        }

        $resourcePath = '/messaging/v1/sms/messages/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($pageSize !== null) {
            $queryParams['$pageSize'] = ObjectSerializer::toQueryValue($pageSize);
        }
        // query params
        if ($lastEventId !== null) {
            $queryParams['lastEventId'] = ObjectSerializer::toQueryValue($lastEventId);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSmsDefinition
     *
     * getSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest
     */
    public function getSmsDefinition(string $definitionKey)
    {
        list($response) = $this->getSmsDefinitionWithHttpInfo($definitionKey);
        return $response;
    }

    /**
     * Operation getSmsDefinitionWithHttpInfo
     *
     * getSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getSmsDefinitionWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest';
        $request = $this->getSmsDefinitionRequest($definitionKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSmsDefinitionAsync
     *
     * getSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getSmsDefinitionAsync(string $definitionKey)
    {
        return $this->getSmsDefinitionAsyncWithHttpInfo($definitionKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSmsDefinitionAsyncWithHttpInfo
     *
     * getSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getSmsDefinitionAsyncWithHttpInfo(string $definitionKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest';
        $request = $this->getSmsDefinitionRequest($definitionKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSmsDefinition'
     *
     * @param  string $definitionKey Unique identifier of the definition to get (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSmsDefinitionRequest(string $definitionKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling getSmsDefinition'
            );
        }

        $resourcePath = '/messaging/v1/sms/definitions/{definitionKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSmsDefinitions
     *
     * getSmsDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetSmsDefinitionsResponse
     */
    public function getSmsDefinitions(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        list($response) = $this->getSmsDefinitionsWithHttpInfo($filter, $pageSize, $page, $orderBy);
        return $response;
    }

    /**
     * Operation getSmsDefinitionsWithHttpInfo
     *
     * getSmsDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetSmsDefinitionsResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getSmsDefinitionsWithHttpInfo(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetSmsDefinitionsResponse';
        $request = $this->getSmsDefinitionsRequest($filter, $pageSize, $page, $orderBy);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetSmsDefinitionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSmsDefinitionsAsync
     *
     * getSmsDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getSmsDefinitionsAsync(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        return $this->getSmsDefinitionsAsyncWithHttpInfo($filter, $pageSize, $page, $orderBy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSmsDefinitionsAsyncWithHttpInfo
     *
     * getSmsDefinitions
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getSmsDefinitionsAsyncWithHttpInfo(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetSmsDefinitionsResponse';
        $request = $this->getSmsDefinitionsRequest($filter, $pageSize, $page, $orderBy);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSmsDefinitions'
     *
     * @param  string $filter Filter by status type. Accepted values are active, inactive, or deleted. Valid operations are eq and neq. (optional)
     * @param  float $pageSize Number of definitions, which are array elements, to return per paged response. (optional)
     * @param  float $page Page number to return. (optional)
     * @param  string $orderBy Sort by a dimension. You can sort by only one dimension. Accepted values are definitionKey, name, createdDate, modifiedDate, and status. (optional)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSmsDefinitionsRequest(string $filter = null, float $pageSize = null, float $page = null, string $orderBy = null)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();


        $resourcePath = '/messaging/v1/sms/definitions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filter !== null) {
            $queryParams['$filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($pageSize !== null) {
            $queryParams['$pageSize'] = ObjectSerializer::toQueryValue($pageSize);
        }
        // query params
        if ($page !== null) {
            $queryParams['$page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($orderBy !== null) {
            $queryParams['$orderBy'] = ObjectSerializer::toQueryValue($orderBy);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSmsSendStatusForRecipient
     *
     * getSmsSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide message key in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse
     */
    public function getSmsSendStatusForRecipient(string $messageKey)
    {
        list($response) = $this->getSmsSendStatusForRecipientWithHttpInfo($messageKey);
        return $response;
    }

    /**
     * Operation getSmsSendStatusForRecipientWithHttpInfo
     *
     * getSmsSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide message key in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function getSmsSendStatusForRecipientWithHttpInfo(string $messageKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse';
        $request = $this->getSmsSendStatusForRecipientRequest($messageKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSmsSendStatusForRecipientAsync
     *
     * getSmsSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide message key in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function getSmsSendStatusForRecipientAsync(string $messageKey)
    {
        return $this->getSmsSendStatusForRecipientAsyncWithHttpInfo($messageKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSmsSendStatusForRecipientAsyncWithHttpInfo
     *
     * getSmsSendStatusForRecipient
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide message key in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function getSmsSendStatusForRecipientAsyncWithHttpInfo(string $messageKey)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\GetDefinitionSendStatusForRecipientResponse';
        $request = $this->getSmsSendStatusForRecipientRequest($messageKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSmsSendStatusForRecipient'
     *
     * @param  string $messageKey Unique identifier to track message send status. You must provide it in singleton requests using the recipient attribute. To provide message key in batch requests, use the recipients array attribute. If you dont provide the message key for recipients, its generated in the response. (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSmsSendStatusForRecipientRequest(string $messageKey)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'messageKey' is set
        if ($messageKey === null || (is_array($messageKey) && count($messageKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $messageKey when calling getSmsSendStatusForRecipient'
            );
        }

        $resourcePath = '/messaging/v1/sms/messages/{messageKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($messageKey !== null) {
            $resourcePath = str_replace(
                '{' . 'messageKey' . '}',
                ObjectSerializer::toPathValue($messageKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation partiallyUpdateEmailDefinition
     *
     * partiallyUpdateEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest
     */
    public function partiallyUpdateEmailDefinition(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body)
    {
        list($response) = $this->partiallyUpdateEmailDefinitionWithHttpInfo($definitionKey, $body);
        return $response;
    }

    /**
     * Operation partiallyUpdateEmailDefinitionWithHttpInfo
     *
     * partiallyUpdateEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function partiallyUpdateEmailDefinitionWithHttpInfo(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest';
        $request = $this->partiallyUpdateEmailDefinitionRequest($definitionKey, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation partiallyUpdateEmailDefinitionAsync
     *
     * partiallyUpdateEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function partiallyUpdateEmailDefinitionAsync(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body)
    {
        return $this->partiallyUpdateEmailDefinitionAsyncWithHttpInfo($definitionKey, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation partiallyUpdateEmailDefinitionAsyncWithHttpInfo
     *
     * partiallyUpdateEmailDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function partiallyUpdateEmailDefinitionAsyncWithHttpInfo(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateEmailDefinitionRequest';
        $request = $this->partiallyUpdateEmailDefinitionRequest($definitionKey, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'partiallyUpdateEmailDefinition'
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function partiallyUpdateEmailDefinitionRequest(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateEmailDefinitionRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling partiallyUpdateEmailDefinition'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling partiallyUpdateEmailDefinition'
            );
        }

        $resourcePath = '/messaging/v1/email/definitions/{definitionKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation partiallyUpdateSmsDefinition
     *
     * partiallyUpdateSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest
     */
    public function partiallyUpdateSmsDefinition(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body)
    {
        list($response) = $this->partiallyUpdateSmsDefinitionWithHttpInfo($definitionKey, $body);
        return $response;
    }

    /**
     * Operation partiallyUpdateSmsDefinitionWithHttpInfo
     *
     * partiallyUpdateSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function partiallyUpdateSmsDefinitionWithHttpInfo(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest';
        $request = $this->partiallyUpdateSmsDefinitionRequest($definitionKey, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation partiallyUpdateSmsDefinitionAsync
     *
     * partiallyUpdateSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function partiallyUpdateSmsDefinitionAsync(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body)
    {
        return $this->partiallyUpdateSmsDefinitionAsyncWithHttpInfo($definitionKey, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation partiallyUpdateSmsDefinitionAsyncWithHttpInfo
     *
     * partiallyUpdateSmsDefinition
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function partiallyUpdateSmsDefinitionAsyncWithHttpInfo(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\CreateSmsDefinitionRequest';
        $request = $this->partiallyUpdateSmsDefinitionRequest($definitionKey, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'partiallyUpdateSmsDefinition'
     *
     * @param  string $definitionKey Unique identifier of the definition. (required)
     * @param  \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function partiallyUpdateSmsDefinitionRequest(string $definitionKey, \SalesForce\MarketingCloud\Model\UpdateSmsDefinitionRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'definitionKey' is set
        if ($definitionKey === null || (is_array($definitionKey) && count($definitionKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $definitionKey when calling partiallyUpdateSmsDefinition'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling partiallyUpdateSmsDefinition'
            );
        }

        $resourcePath = '/messaging/v1/sms/definitions/{definitionKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($definitionKey !== null) {
            $resourcePath = str_replace(
                '{' . 'definitionKey' . '}',
                ObjectSerializer::toPathValue($definitionKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendEmailToMultipleRecipients
     *
     * sendEmailToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse
     */
    public function sendEmailToMultipleRecipients(\SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body)
    {
        list($response) = $this->sendEmailToMultipleRecipientsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation sendEmailToMultipleRecipientsWithHttpInfo
     *
     * sendEmailToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function sendEmailToMultipleRecipientsWithHttpInfo(\SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse';
        $request = $this->sendEmailToMultipleRecipientsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendEmailToMultipleRecipientsAsync
     *
     * sendEmailToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function sendEmailToMultipleRecipientsAsync(\SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body)
    {
        return $this->sendEmailToMultipleRecipientsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendEmailToMultipleRecipientsAsyncWithHttpInfo
     *
     * sendEmailToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function sendEmailToMultipleRecipientsAsyncWithHttpInfo(\SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse';
        $request = $this->sendEmailToMultipleRecipientsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendEmailToMultipleRecipients'
     *
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendEmailToMultipleRecipientsRequest(\SalesForce\MarketingCloud\Model\SendEmailToMultipleRecipientsRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendEmailToMultipleRecipients'
            );
        }

        $resourcePath = '/messaging/v1/email/messages/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendEmailToSingleRecipient
     *
     * sendEmailToSingleRecipient
     *
     * @param  string $messageKey Unique identifier used to track message status. Can be automatically created when you create a message or provided as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse
     */
    public function sendEmailToSingleRecipient(string $messageKey, \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body)
    {
        list($response) = $this->sendEmailToSingleRecipientWithHttpInfo($messageKey, $body);
        return $response;
    }

    /**
     * Operation sendEmailToSingleRecipientWithHttpInfo
     *
     * sendEmailToSingleRecipient
     *
     * @param  string $messageKey Unique identifier used to track message status. Can be automatically created when you create a message or provided as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function sendEmailToSingleRecipientWithHttpInfo(string $messageKey, \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse';
        $request = $this->sendEmailToSingleRecipientRequest($messageKey, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendEmailToSingleRecipientAsync
     *
     * sendEmailToSingleRecipient
     *
     * @param  string $messageKey Unique identifier used to track message status. Can be automatically created when you create a message or provided as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function sendEmailToSingleRecipientAsync(string $messageKey, \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body)
    {
        return $this->sendEmailToSingleRecipientAsyncWithHttpInfo($messageKey, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendEmailToSingleRecipientAsyncWithHttpInfo
     *
     * sendEmailToSingleRecipient
     *
     * @param  string $messageKey Unique identifier used to track message status. Can be automatically created when you create a message or provided as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function sendEmailToSingleRecipientAsyncWithHttpInfo(string $messageKey, \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse';
        $request = $this->sendEmailToSingleRecipientRequest($messageKey, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendEmailToSingleRecipient'
     *
     * @param  string $messageKey Unique identifier used to track message status. Can be automatically created when you create a message or provided as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendEmailToSingleRecipientRequest(string $messageKey, \SalesForce\MarketingCloud\Model\SendEmailToSingleRecipientRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'messageKey' is set
        if ($messageKey === null || (is_array($messageKey) && count($messageKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $messageKey when calling sendEmailToSingleRecipient'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendEmailToSingleRecipient'
            );
        }

        $resourcePath = '/messaging/v1/email/messages/{messageKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($messageKey !== null) {
            $resourcePath = str_replace(
                '{' . 'messageKey' . '}',
                ObjectSerializer::toPathValue($messageKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendSmsToMultipleRecipients
     *
     * sendSmsToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse
     */
    public function sendSmsToMultipleRecipients(\SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body)
    {
        list($response) = $this->sendSmsToMultipleRecipientsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation sendSmsToMultipleRecipientsWithHttpInfo
     *
     * sendSmsToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function sendSmsToMultipleRecipientsWithHttpInfo(\SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse';
        $request = $this->sendSmsToMultipleRecipientsRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendSmsToMultipleRecipientsAsync
     *
     * sendSmsToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function sendSmsToMultipleRecipientsAsync(\SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body)
    {
        return $this->sendSmsToMultipleRecipientsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendSmsToMultipleRecipientsAsyncWithHttpInfo
     *
     * sendSmsToMultipleRecipients
     *
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function sendSmsToMultipleRecipientsAsyncWithHttpInfo(\SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToMultipleRecipientsResponse';
        $request = $this->sendSmsToMultipleRecipientsRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendSmsToMultipleRecipients'
     *
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendSmsToMultipleRecipientsRequest(\SalesForce\MarketingCloud\Model\SendSmsToMultipleRecipientsRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendSmsToMultipleRecipients'
            );
        }

        $resourcePath = '/messaging/v1/sms/messages/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendSmsToSingleRecipient
     *
     * sendSmsToSingleRecipient
     *
     * @param  string $messageKey Unique identifier of the definition used to track message status. The messageKey can be created automatically when you create a message, or you can provide it as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     * @return \SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse
     */
    public function sendSmsToSingleRecipient(string $messageKey, \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body)
    {
        list($response) = $this->sendSmsToSingleRecipientWithHttpInfo($messageKey, $body);
        return $response;
    }

    /**
     * Operation sendSmsToSingleRecipientWithHttpInfo
     *
     * sendSmsToSingleRecipient
     *
     * @param  string $messageKey Unique identifier of the definition used to track message status. The messageKey can be created automatically when you create a message, or you can provide it as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @return array of \SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \GuzzleHttp\Exception\GuzzleException
     * @throws \SalesForce\MarketingCloud\ApiException on non-2xx response
     */
    public function sendSmsToSingleRecipientWithHttpInfo(string $messageKey, \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse';
        $request = $this->sendSmsToSingleRecipientRequest($messageKey, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                /** @var \GuzzleHttp\Psr7\Response $response */
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw ExceptionFactory::create($e);
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw ExceptionFactory::create(new RequestException(sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $response->getStatusCode(),
                    $request->getUri()
                ), $request, $response));
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = \GuzzleHttp\json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SalesForce\MarketingCloud\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendSmsToSingleRecipientAsync
     *
     * sendSmsToSingleRecipient
     *
     * @param  string $messageKey Unique identifier of the definition used to track message status. The messageKey can be created automatically when you create a message, or you can provide it as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     */
    public function sendSmsToSingleRecipientAsync(string $messageKey, \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body)
    {
        return $this->sendSmsToSingleRecipientAsyncWithHttpInfo($messageKey, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendSmsToSingleRecipientAsyncWithHttpInfo
     *
     * sendSmsToSingleRecipient
     *
     * @param  string $messageKey Unique identifier of the definition used to track message status. The messageKey can be created automatically when you create a message, or you can provide it as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws Exception\ClientUnauthorizedException
     * @throws \InvalidArgumentException
     */
    public function sendSmsToSingleRecipientAsyncWithHttpInfo(string $messageKey, \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body)
    {
        $returnType = '\SalesForce\MarketingCloud\Model\SendDefinitionToSingleRecipientResponse';
        $request = $this->sendSmsToSingleRecipientRequest($messageKey, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = \GuzzleHttp\json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    /** @var \GuzzleHttp\Psr7\Response $response */
                    /** @var \GuzzleHttp\Exception\RequestException $exception */
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendSmsToSingleRecipient'
     *
     * @param  string $messageKey Unique identifier of the definition used to track message status. The messageKey can be created automatically when you create a message, or you can provide it as part of the request. Each recipient in a request must have a unique messageKey. If you use a duplicate messageKey in the same send request, the message is rejected. (required)
     * @param  \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body JSON Parameters (required)
     *
     * @throws \InvalidArgumentException
     * @throws Exception\ClientUnauthorizedException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendSmsToSingleRecipientRequest(string $messageKey, \SalesForce\MarketingCloud\Model\SendSmsToSingleRecipientRequest $body)
    {
        if (isset($body) && !$body->valid()) {
            throw new InvalidRequestException($body, "The request data is invalid");
        }

        $this->authorizeClient();

        // verify the required parameter 'messageKey' is set
        if ($messageKey === null || (is_array($messageKey) && count($messageKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $messageKey when calling sendSmsToSingleRecipient'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendSmsToSingleRecipient'
            );
        }

        $resourcePath = '/messaging/v1/sms/messages/{messageKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($messageKey !== null) {
            $resourcePath = str_replace(
                '{' . 'messageKey' . '}',
                ObjectSerializer::toPathValue($messageKey),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        // Set the header for the authorization access token
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $headers['User-Agent'] = static::getUserAgent();

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

}
